{"title":"web加载性能优化","date":"2019-06-25T16:01:09.000Z","link":"post/web加载性能优化","tags":["web"],"updated":"2019-06-28T15:01:05.769Z","content":"<h1 id=\"web加载性能优化\">web加载性能优化<a href=\"post/web加载性能优化#web加载性能优化\"></a></h1><h2 id=\"总体原则\">总体原则<a href=\"post/web加载性能优化#总体原则\"></a></h2><ol>\n<li>能不请求就不请求</li>\n<li>必须请求的尽量减少大小</li>\n<li>用到时才去请求</li>\n</ol>\n<p>加载性能的优化总结起来就是，两文件两http优化。两文件其实是文本和图像这两类文件，两http是减少http请求，使用http缓存。</p>\n<h2 id=\"文本文件\">文本文件<a href=\"post/web加载性能优化#文本文件\"></a></h2><p>文本文件包括html、css、js等，该类文件优化的步骤都是<strong>先minify，后gzip</strong>。<br>再进一步可能需要做一些分包跟懒加载。</p>\n<h2 id=\"图像文件\">图像文件<a href=\"post/web加载性能优化#图像文件\"></a></h2><p>图像文件包括png、jpg、svg、gif等。优化这类文件，可以考虑以下几个步骤：</p>\n<ul>\n<li>剪裁</li>\n<li>使用合适的格式</li>\n<li>降低图片质量（压缩）</li>\n<li>去除元数据</li>\n</ul>\n<p>最容易犯错的是，下载分辨率过高的图片。在客户端，我们可能只需要一张尺寸很小的图片，但是因为原始图片尺寸很大，并且开发者想这可以在客户端对图片进行剪裁，就会直接将原尺寸图片下载下来。</p>\n<p>这样做不好的地方在于，第一图片请求返回的时间会很长，第二在客户端进行剪裁会占用cup，消耗性能。</p>\n<p>比较好的做法是在服务器或图床中就对图片进行剪裁，只下载合适大小的图片。</p>\n<h2 id=\"减少http请求\">减少http请求<a href=\"post/web加载性能优化#减少http请求\"></a></h2><p>合并js、css、图片(css sprite)，这一块在http2下不一定适用。后续总结一波http2。</p>\n<h2 id=\"使用http缓存\">使用http缓存<a href=\"post/web加载性能优化#使用http缓存\"></a></h2><p>对不会经常变的文件，可以加上缓存，这样在再次访问页面的时候，可以加快访问速度。不做过多介绍，后续总结一下强缓存和协商缓存。</p>\n","prev":{"title":"前端缓存介绍","link":"post/前端缓存介绍"},"next":{"title":"antd按需加载","link":"post/antd按需加载"},"plink":"http://yoursite.com/post/web加载性能优化/","toc":[{"title":"web加载性能优化","id":"web加载性能优化","index":"1","children":[{"title":"总体原则","id":"总体原则","index":"1.1"},{"title":"文本文件","id":"文本文件","index":"1.2"},{"title":"图像文件","id":"图像文件","index":"1.3"},{"title":"减少http请求","id":"减少http请求","index":"1.4"},{"title":"使用http缓存","id":"使用http缓存","index":"1.5"}]}]}